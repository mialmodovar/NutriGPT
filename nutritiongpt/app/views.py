from django.shortcuts import render

from django.views.generic import TemplateView

from django.utils import timezone
from django.views.generic import TemplateView

import time
from django.db.models import F
from django.contrib.auth.forms import AuthenticationForm
from django.shortcuts import render, redirect
from django.contrib.auth.forms import UserCreationForm , AuthenticationForm
from django.contrib.auth import logout as auth_logout
from django.contrib.auth.decorators import login_required
from django.shortcuts import render, redirect
from django.contrib.auth import login as auth_login
from .models import UserProfile, DailyIntake
from .forms import UserProfileForm
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
import re
import os
from dotenv import load_dotenv
import openai
load_dotenv()  # Load the .env file

gpt4_api_key = os.getenv('OPEN_AI')

@csrf_exempt
def chatbot_response(request):
    if request.method == 'POST':
        message = request.POST.get('message')
        
        # Initialize the OpenAI API with your API key
        openai.api_key = gpt4_api_key
        
        # Get the user's calorie goal and current calories
        user = request.user
        user_profile = UserProfile.objects.get(user=user)
        daily_intake = DailyIntake.objects.get(user=user, date=timezone.now())

        # Generate a response using GPT-4
        prompt = f"{message}\nCALORIE_GOAL: {user_profile.calories_goal}\nCURRENT_CALORIES: {daily_intake.calories}"
        init = '''Data Handling: You are a fitness computer for a fitness app interacting with users using natural language. You will receive the user's current stats at the end of each prompt: CALORIE GOAL: G and CURRENT CALORIES: C.

Setting Calorie Goal: When a user requests to set their calorie goal (e.g., "I want to set my calorie goal to 2000"), acknowledge the request with 'Your calorie goal has been set to L'. After a line break, print "UPDATE_DB" and "UPDATED_CALORIE_GOAL: L".

Calorie Tracking: Pay attention when the user mentions what they've eaten. If the user doesn't specify the amount of food, assume one serving. Register the food and its calorie count. After every message where you detect this, print "UPDATE_DB" and "CALORIES_ADDED: Y" after a line break, where Y represents the calories of the eaten food.

Exercise Tracking: If a user mentions they've done some exercise, calculate the estimated calories burnt and print "UPDATE_DB" and "CALORIES_REMOVED: Y" after a line break, where Y is the estimated calories burnt.

Undoing Actions: If the user undoes an action, print "CALORIES_REMOVED: Y" where Y is the calorie count of the undone food or exercise.

Meal Suggestions: When asked for meal suggestions to meet their daily calorie goal, calculate the remaining required calories (G-C=D) and suggest meals totaling approximately D calories.

Hidden Updates: The user should not see the updates mentioned in points 2, 4, and 5. Place these after a line break at the end of your responses, preceded by "UPDATE_DB".

Insights and Conversations: Maintain a conversational tone, providing brief insights (max 20 words) about healthy eating and lifestyle whenever the user shares information about their food intake or exercise. Make sure to hide that you are a computer as much as possible.

Scope of Interactions: Only respond to queries related to nutrition, healthy lifestyle, gym, exercising, yoga, self-care, and mental health. Ignore all other subjects.

Current Stats: Feel free to share the user's current stats when relevant to the conversation.

Python String Formatting: Ensure all responses are correctly formatted as Python strings, using line breaks ("\\n") for proper formatting and readability."'''

        initprompt = f"{init}"
        response = openai.ChatCompletion.create(
        model='gpt-4',
        messages=[
            {"role": "system", "content": initprompt},
            {"role": "assistant", "content": "OK."},
            {"role": "user", "content": prompt}
        ],
        max_tokens=800,
        temperature = 0.6
    )   
        print(response)
        # Extract the first response generated by GPT-4
        bot_response = response['choices'][0]['message']['content'].strip()

        # Check if "UPDATE_DB" is in the response
        if "UPDATE_DB" in bot_response:
            bot_response, db_update = bot_response.split("UPDATE_DB", 1)
        else:
            db_update = None
        print(db_update)
        update_dict = {}
        if db_update:
            update_strings = ["UPDATED_CALORIE_GOAL", "CALORIES_ADDED", "CALORIES_REMOVED"]
            for string in update_strings:
                if string in db_update:
                    # Extract the number after the string (and colon)
                    match = re.search(f"{string}: ([\d\.]+)", db_update)
                    if match:
                        number = match.group(1)
                        
                        # Remove any leading/trailing whitespace and convert to float
                        number = float(number.strip())
                        
                        # Store the value in the dictionary
                        update_dict[string] = number
        print(update_dict)
        # Update the UserProfile and DailyIntake instances based on the updates in update_dict
        if "UPDATED_CALORIE_GOAL" in update_dict:
            user_profile.calories_goal = update_dict["UPDATED_CALORIE_GOAL"]
            user_profile.save()

        if "CALORIES_ADDED" in update_dict:
            daily_intake.calories = F('calories') + update_dict["CALORIES_ADDED"]
            daily_intake.save()

        if "CALORIES_REMOVED" in update_dict:
            daily_intake.calories = F('calories') - update_dict["CALORIES_REMOVED"]
            daily_intake.save()
        bot_response = f"{bot_response}"
        bot_response = bot_response.replace('\n', '<br>')
        return JsonResponse({'response': bot_response})
    
    return JsonResponse({'error': 'Invalid request method'})

@login_required
def index(request):
    return render(request, 'app/chat.html')

def register(request):
    if request.method == 'POST':
        form = UserCreationForm(request.POST)
        if form.is_valid():
            user = form.save()

            # Create UserProfile instance
            user_profile = UserProfile(user=user)
            user_profile.save()

            # Create DailyIntake instance
            daily_intake = DailyIntake(user=user, date=timezone.now())
            daily_intake.save()

            time.sleep(3)
            auth_login(request, user)
            print('User created successfully!')
            return redirect('index') # Replace 'index' with the name of the view where you want to redirect after successful registration
        else:
            print('User creation failed!')
    else:
        form = UserCreationForm()
    return render(request, 'app/register.html', {'form': form})



def login(request):
    if request.method == 'POST':
        form = AuthenticationForm(request, data=request.POST)
        if form.is_valid():
            auth_login(request, form.get_user())
            return redirect('index') # Replace 'index' with the name of the view where you want to redirect after successful login
    else:
        form = AuthenticationForm()
    return render(request, 'app/login.html', {'form': form})

@login_required
def logout(request):
    auth_logout(request)
    return redirect('login')  # Replace 'login' with the name of the view where you want to redirect after logout

@login_required
def edit_profile(request):
    # Get the current user's UserProfile or create one if it doesn't exist
    user_profile, created = UserProfile.objects.get_or_create(user=request.user)

    if request.method == 'POST':
        form = UserProfileForm(request.POST, instance=user_profile)
        if form.is_valid():
            form.save()
            return redirect('profile')  # Replace 'profile' with the name of the view where you display the user's profile
    else:
        form = UserProfileForm(instance=user_profile)

    context = {'form': form}
    return render(request, 'app/editprofile.html', context)